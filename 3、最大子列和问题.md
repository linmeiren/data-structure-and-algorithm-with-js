

# 问题描述

最大子列和问题，就是存在一个无限长的数列，数组中的元素有正数也有负数，在这个数列中取 n 个数，计算在这个 n 个数组成的数列中，在它的许许多多个子列中，哪一个子列的和最大。

从第一眼看，这个问题好像真的很复杂，首先 n 个数，里面有正数也有负数，顺序不定；这 n 个数的序列，它的子列的数量就更多了。那我们要怎么办呢？

# 问题解法

首先比较笨的一种方式是使用嵌套循环，既然是 n 个数组成的数列，那我就从第一个数开始，依次往后取数列相加，每次比较相加的和，保存大者；下一轮就从第二个数开始，依次往后取数列相加，直到所有的数都加完。

算法的实现过程可以这样：

### 第一种：

```
    function getMax(arr, n){ // arr 表示那个无限长的数列， n 表示那个取的数列长度
        let max = 0;
        let tempVal = 0;
        for(let i = 0; i < n; i++) {
            for(let j = i; j < n; j ++) {
                for(k = i; k < j; k++) {
                    tempval += arr[k];
                    if (tempVal > max) {
                        max = tempVal;
                    }
                }
            }
        }
        return max;
    }

```
以上算法看起来简单暴力，实际上也是简单暴力，使用了三层循环，时间复杂度是 S(n) = O(n^3)，效率十分低，认真想一下其实中间是存在非常多的重复操作的。

### 第二种：

其实我们看，在第二轮循环之后，开始计算每一次的和，其实并不需要每次都从 i 到 j 进行相加。本轮的结果可以从上一轮的结果加一个数就可以得到。

修改为：
```
    function getMax(arr, n){
        let max = 0;
        let temp = 0;
        for(let i = 0; i < n; i ++) {
            temp = 0;
            for(let j = i; j < n; j ++) {
                temp +=arr[j];
                if (temp > max) {
                    max = temp;
                }
            }
        }
        return max;
    }
```

以上算法的时间复杂度是 T(n) = O(n^2)

### 第三种：分而治之

分而治之的思想，就是把一个很复杂的问题，分解成一些很小的部分，进行小部分的分析，然后再使用递归的方式进行大问题的解决。

以上的最大子列和问题求 n 个数的最大最大子列和，可以先把这 n 个数分成左右两部分，其实最大的子子列和，要么是左边的一部分的最大子列和，要么是右边的部分的最大子列和，还有一种情况就是跨越了中间分割线的一个子列的最大子列和。

以此类推，我们还可以将左边、右边的两个部分进行分割，按照刚在的方式求出每一部分的最大子列和。然后进行比较得出。

例如，现在有一个数组就是 5, -3, -4, 2, -2, 5, 8, -3，求最大子列和。我们先看左边 5, -3, -4, 2，将左边再一分为二，看左边一部分是 5, -3，这两个数左边是 5，右边是 -3
，跨越他们中间的子列 5, -3 的和是 2，此时可以得到，这一部分最大的子列和是 5，然后依次类推，得到所有部分的子列和。

现在我们想要求出这种方法的时间复杂度，该怎么办呢。其实这种递归方式出现的过程一般都是需要进行推导才能得到复杂度公式的。

从上面过程我们可以看出，分割数列的时间复杂度是等于左边的复杂度 + 右边的复杂度 + 跨越中间分界线的复杂度：

```
    T(1) = O(1)
    
    T(n) = 2*T(n/2)  + C*n
         = 2*(2*T(n/4) + C*n/2) + C*n = 2^2*T(n/2^2) + 2*C*n
         
    从以上过程推导 k 次，因为每一次都是分成左右两半，假设拆分到 k 次之后，得到了 O(1)，可以得到以下公式：
    
    T(n) = 2^k*T(n/2^k) + k*C*n = 2^k*O(1) + k*C*n    其中 n/2^k = 1，即 n = 2^k, k = log2(n)
    
    所以：
    
    T(n) = C*n*log2(n) + O(1)*n
    
    所以时间复杂度是 n*log2(n)
```

那么空间复杂度呢？因为整个过程一共递归拆分了 k 次，所以空间复杂度是 k，上面推导出 k = log2(n)，所以空间复杂度是 log2(n)

 在整个算法执行的过程中只为数组开了空间，所以整体的空间复杂度为（取大原则）：O（N）

（我日，好尼玛牛逼啊~）

### 第四种：在线处理

这么理解在线处理呢？

因为我们要求的最大子列和是连续的子列，而且只要和最大，子列元素个数是不限制的。

所以我们可以一项一项的加，先把最大的存起来，然后如果加到出现结果为负数的，那就先把之前加的舍弃，但是最大的值先留着。

然后重新从一个新的下一个位置往后加，直到末尾。

比方说我们现在的数列只有 4 个数，要计算这四个数构成的数列的最大子列和，我们可以先算前面第一个数，如果前面第一个数是正数，那我们就留着，如果是负数，那我们就不把他计入最大子列和里面，将前一次加的结果记为 0，

接下来加后面一个数，以此类推。

比如数列是：-1， 3， -2， 4， -6， 1， 6， -1

写成代码：

```
    function maxSubseQueSum(arr, n) {
        let thisSum = 0;
        let maxSum = 0;
        for(let i = 0; i < n; i ++) {
            thisSum += arr[i];
            if (thisSum > maxSum) {
                maxSum = thisSum;
            } else if (thisSum < 0) {
                thisSum = 0;
            }
        }
        return maxSum;
    }

    沃妮马，牛逼啊！

```
该算法的时间复杂度是： T(n) = O(n);


如果该算法不仅要输出最大子列和，还要输出相应那个子列的首尾索引。怎么写呢？

```
    
    比如数列是：-1， 3， -2， 4， -6， 11， -16， 22

    function max() {
    
        let thisSum = 0;
        let thisStartIndex = 0;
        let thisEndIndex = 0;
        
        let maxSum = 0;
        let maxStartIndex = 0;
        let maxEndIndex = 0;
        
        for(let i = 0; i < n; i++) {
            thisSum += arr[i];
            thisEndIndex = i;
            
            if (thisSum > maxSum) { // 遇到比 maxSum 大的结果，就把索引都存起来
                maxStartIndex = thisStartIndex;
                maxEndIndex = thisEndIndex;
                
            } else if (thisSum < 0) {
                thisSum = 0;
                
                thisStartIndex = i + 1; // thisSum < 0 说明加的是一个负数，所以开始索引跳过该数字
            }
        }
    }

```
