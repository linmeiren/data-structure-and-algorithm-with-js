
# 什么是算法呢？

通俗的说：算法其实就是解决问题的思路，解决问题每一步的目的必须明确，步骤数量要求是有限的，并且问题解决的最后必须要有一个结果，就是输出。

比如下面有一个问题需要解决：将一个乱序的数字集合进行从大到小排列，最后输出这个数字集合

```
    // 按照上面算法的概念，算法应该是不依赖任何形式和语言的，所以我们使用伪代码来描述上述问题的解决方式
    // 我们可以先采用函数的形式进行问题算法的描述
    
    function selectSort(list){
        for(let i = 0; i < list.length; i++) {
            
            // 每次循环找到当前位置到最后的最小的那个值的索引
            let minPosition = scanForMin(list, i, list.length);

            // 将找到的最小值与当前值进行交换位置（具体怎么教换，我们不关心）
            Swap(list[i], list[minPosition]);
        }
    }
    
    // 上述结构中，传进来的不一定是数组，也可以是链表，里面的for循环只是一种方式，每次循环里面实现目的的方法细节，不用关心，这就是算法。
```
所以算法应该是这样的：

    算法应该是有限步骤的指令集，每个步骤意思明确，不一定有输入，但是一定要有输出。
    
    算法应该是不依赖于任何在载体或者语言的

那既然算法是这样，方法有多种多样，那有没有区别呢？答案肯定是有...

# 什么是好的算法？

区别算法好坏，我们通常会使用两个指标来判断：

### 1、空间复杂度

什么是空间复杂度呢？

算法肯定要落地到具体的程序才有意义，而程序的运行需要内存空间；空间复杂度就是用来描述程序运行时占用空间的大小。

空间复杂度过高的程序会导致程序崩溃，执行中断。

空间复杂度一般是跟数字的规模成正比。

例如，我们写程序时，递归调用就是一种空间复杂度很高的写法，每次执行下一轮时都需要把上一轮的状态进行储存，随着 n 增大，储存状态需要的内存空间不断增大。

```
    function printN(n) {
        if (n) {
            pringN(n-1);
        }
        console.log(n);
    }

```
执行该程序时，假如输出数字 n = 100，那么当将 100 代入执行时，需要先执行 printN(99),此时就需要将 print(100) 的执行状态进行保存；当执行print(99)时，需要先执行 printN(98),此时就要先保存 printN(99)的状态，以此类推，每次执行都需要先保存上一次的执行状态，占用空间随着规模成一次函数增长。

此时的空间复杂度：
```
    S(n) = C * n
```

如果算法是使用一个 for 循环进行一个一个输出：

```
    function printN(n) {
        for(let i = 0; i < n; i ++) {
            console.log(i);
        }
    }
```
在 for 循环中，每依次循环都输出一个数字，并且上一次循环已经完成，占用的内存空间将会退出，下一次循环时又重新占用一个单位的内存，这样总共就占用一个单位的内存，而不是像上面的递归算法一样，占用的内存空间成一次函数式增长。

此时的空间复杂度：

```
    S(n) = C
```

### 2、时间复杂度

什么是时间复杂度呢？

根据算法写成的程序，执行得到最后结果，过程中所花费的时间称为该算法的时间复杂度。

时间复杂度跟我们执行程序的步骤数量，还有每一步执行所需要的时间有关。对于执行时间相差很大的步骤来说，执行时间短的可以忽略。（例如，计算乘除法需要消耗的时间要比计算加减法需要的时间要多得多，这种情况下我们一般只要看计算乘除法的个数即可得到时间复杂度的相对大小）

例如：

我们求多项式的和，前面数据结构章节有说到两种算法（加减法在乘除法在执行时间上可以忽略不计）：

##### 1、算法一

```
    function sum(n){
        let sum = 0;
        for(let i = 0; i < n; i ++) {
            sum += a[i] * Math.pow(x, i);
        }
        return sum;
    }
```
在这个算法中进行了 for 循环 n 次，第 i 次循环乘法执行 i 次，所以时间复杂度就是 T(n) = C * (1 + 2 + 3 + ... + n),即：T(n) = C * n * (n + 1)/2 


##### 2、算法二

```
    function sum(n) {
        let sum = a[n];
        for(let i = n; i > 0; i --) {
            p = a[n-1] + x*p;
        }
    }

```
在这个算法中，for 循环的每一次循环中，乘法只执行了一次，所以时间复杂度：T(n) = C * n

由此可看出上面两种算法，随着 n 的不断增大，时间复杂度的差别将会越来越大。导致程序执行时间差距越来越大。方法二明显优于方法一

# 复杂度的判定方向

通常我们判定一个算法好与不好，在时间复杂度和空间复杂度两个维度上面，采用判定方式有两种：

- 1、最坏复杂度 T （worst）(n)：就是设计的算法的最坏情况，运行到程序的最后才得出结果
 
- 2、平均复杂度 T（aug）(n)

我们在分析问题是采用的比较多的是最坏复杂度，因为分析平均复杂度会非常之难。

### 尝试使用伪代码描述二分法来说明几种复杂度（查找算法中的一种）

```
    ow = 0;
    high = List.length - 1;
    当low < high时
        mid = （low + high) / 2;
        如果List[mid] < X
            low = mid + 1;
        如果List[mid] > X
            high = mid - 1;
        否则
            返回 mid
    
    最坏时间复杂度为O(log2n)
    最好时间复杂度为O(1)
    空间复杂度均为O(1)
```

# 复杂度的渐进式表示法

我们在分析一个算法的复杂度的时候，是否有必要去分析算法的每一步的执行情况，以及某个操作执行了多少次呢？是否有这个必要呢，答案是否定的。

我们在分析一个算法的时候，通常只需要知道这个算法在数据规模增大的过程中，他的复杂度大致呈现什么样的增长速度就行了。

也就是说我们可以找到一个函数来大致描述这个算法的增长过程。在描述的函数中我们也通常只需要看对增长影响最大的那一项就可以了。

## 什么是复杂度的渐进值式表示呢

- 1、复杂度的上界

如果一个时间复杂度表示为 T(n),则存在一个 O(f(n))，表示存在常数 C > 0, n0 > 0, 使得当 n > n0 时，有 T(n) <= C * f(n)

- 2、复杂度的下界

如果一个时间复杂度表示为 T(n),则存在一个 Ω(g(n))，表示存在常数 C > 0, n0 > 0,使得当 n > n0 是，有 T(n) >= C * f(n)

- 3、复杂度的不变区域

如果一个时间复杂度表示为 T(n), T(n) = θ(h(n))，表示同时有 T(n) = O(h(n)) 和 T(n) = Ω(h(n))，表示上界和下界相同

一般我们在描述复杂度的时候，都会存在多个上界或者下界，但是对于太大的上界和太小的下界，对于我们分析复杂度并没有太大的帮助，我们在分析复杂度的时候总是希望它能够与真实情况贴合的越近越好。

当我们在找 O(f(n)) 的时候，通常寻找的是我们能找到的最小的上界，当在寻找 Ω(g(n)) 的时候，通常寻找的是我们能找到的最大的下界。

我们常见的描述复杂度的函数可能会有：常数、log n、n*log n、n^2 、n^3 、2^n、n! 等等，每一种函数的变化趋势都不一样，并且呈现等级性质的增长，如果在写算法的时候能够将复杂度从一个等级，下调到另外一个等级，那带来的效率将会是不可估量的。

# 复杂度分析的常用窍门

- 1、如果我们有两段算法分别有复杂度 T1 = O(f(n)) 和 T2 = O(f(n))，

如果我们把两段算法拼在一起，那他们的复杂度将会是二者之和，复杂度的上界将会是两个复杂度上界比较大的那个。T1(n) + T2(n) = max(O(f(n)), O(f(n)));

如果我们把两段算法嵌套在一起，那他们的复杂度将会是二者之乘积，复杂度的上界将会是两个复杂度上界的乘积。

- 2、如果一个复杂度是关于 n 的 k 阶多项式，那么复杂度由阶数最高的那一项决定，其他的项都是可以忽略不记的。

- 3、for 循环的时间复杂度等于循环次数 * 每一次循环代码的复杂度

- 4、对于 if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分支部分的复杂度，总体复杂度取决于三者中最大的那个。

举例：

分析下面一段代码的时间复杂度

```
    if(a > b){
        for(let i = 0; i < n; i++) {
             for ( j = n * n; j > i; j--) {
                a += b;
             }
        }
    } else {
        for ( i = 0; i < n * 2; i++){
            for ( j = n * 2; j > i; j--){
                a += b;    
            }
        }
        
    }
```
