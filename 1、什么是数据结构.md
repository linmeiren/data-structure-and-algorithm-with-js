
# 1、概念

其实数据结构没有特别明确公认的概念。

在《数据结构、算法与应用》中说道：数据结构是对象，以及存在于该对象的实例和组成该对象的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。

在《数据结构和算法分析》中说道：数据结构是抽象数据类型的物理实现。

在《中文维基百科》中说道：数据结构是计算机中储存、组织数据的方式。通常情况下，精心选择的数据结构可以带来最有效率的算法。

其实这些概念看起来相差不大，但是都有些不好理解。一两句话其实无法真正说明数据结构和算法是什么。

那接下来我们看一些例子

# 问题一：图书馆书架上如何摆放书籍

## 问题描述

其实这个问题不是很科学，因为问题根本没有说明图书馆的书架是什么样子，以及图书馆中一共有多少本书籍。

那我们先跳过这些问题不考虑。就摆放问题，想看有哪些摆放方式。

这个问题在思考之前，我们首先需要理解一些基本前提，那就是图书馆摆放数据，无非就是要实现基本四种功能，也是我们日常日常管理数据过程中各种操作以之为基础的四种基本操作：增删改查。

再看“增删改查”这四种基本操作，其实首先我们要实现的是增加和查找这两个基本的过程。

再回到图书馆如何拜访书籍的问题,可能会想到以下的方式：

 - 1、随便摆放，就是把所有的书籍按照一字排开的方式进行摆放，不管他们是属于那种类型的书。
 
    这样的方式的好处就是，当新来一本书的时候，我们不需要考虑这本书需要放在哪里，直接放在之前摆好的一列书的末尾就行。

    坏处就是，如果我们想要找到其中一本书，那就是一件让人头疼不已的事情，书的数量少的话还好，如果书的数量已经到达的一定的数量级，那这样的查找就会是致命的。

- 2、按照书名的首字母进行排列
 
    这样的话，当新来一本书的时候，可以按照二分法，一次一次查找到这本书是在哪一个首字母下面的（先不管每个字母下面有多少本书），要查找一本书的话也按照这种方法进行查找。

    但是这样有一个问题就是，如果要查找的书是以 a 开头的，如果也按照这种查找方式就行查找，就白白浪费了很多不需要的查找。

- 3、所有的书籍按照首字母的排列顺序进行分类，每个类别在按照书名首字母进行分类，每个首字母下面进行编号摆放。

    这样如果再来一本书，就可以通过分类 - 首字母 - 编号就行查找。

通过以上的集中方法的讨论，可以看出来要实现一种两全其美的方式还真的不是一件容易的事情。

## 实际

在实际生活中，我们在书城查找一本书，首先是看它属于哪一个学科，类别，找到对应的区域，然后再找到书名的首字母进行查找。这种方式其实是因为我们人类到达特定的分类下面，可以按照我们的理解直接去到对应首字母下面的书籍当中去寻找，而不是使用二分法。

## 分配

接下来新的问题又来了，假如你是一名图书管理员，在按照以上方式进行图书分类之后，分配给每一种图书的空间是多少呢？

在实际情况下每一类别的书的数量应该是不一样的，如果我们分配少了，一直去给某一类图书拓展空间其实是一件特别费事的事情。如果分配多了又造成资源空间的浪费。

另外的一个问题，类别应该要分多细才是比较切当的呢，如果类别分的太粗，就会造成每一种图书类别下面的数量太多。如果类别分的太细，就会造成类别太多，复杂度上升。

## 结论

其实图书管理的例子只是想说明数据结构一个问题，就是==数据的组织方式，直接影响到解决问题的效率。==


# 问题二：输出从 1 - N 的数字

## 问题描述

写一个函数，实现输出从 1 - N 的整数。

## 实现方式

- 1、直接使用 for 循环

```
    function printN(n) {
        if ( n <= 0) {
            return false;
        }
        n = Math.floor(n);
        
        for(let i = 1; i <= n; i++) {
            console.log(i)
        }
    }

```

- 2、使用函数递归的方式

```
    function printN(n) {
        if ( n <= 0) {
            return false;
        }
        n = Math.floor(n);
        
        if (n) {
            printN(n - 1);
            console.log(n);
        }
    }
    
```

上面两段代码，看起来代码的数量是差不多的，但是执行起来所要消耗的资源是不同的。第二种方法使用的递归会严重侵占内存，只要传入的数字过大，那么就会出现内存溢出而导致程序崩溃。


# 问题三：计算一个多项式的值

## 问题描述

给定一个多项式，计算给定项数的多项式的和。比如多想是通项是：an-1*x ^(n-1)

 那么前 n 项和就是：f(x) = a0 + a1 * x + a2 * x ^ 2 + ... + an-1*x ^(n-1)

这里的 a0,a1,a2,...an-1 是通过一个数组元素来描述。

## 问题解决

- 1、实现方式一，直接使用 for 循环进行累加（这种写法可能会被鄙视）

```
    function count(x, arr) {
        let length = arr.length;
        let result = 0;
        for (let i = 0; i < length; i++) {
            result += arr[i] * Math.pow(x, i);
        }
        return result;
    }

```
- 2、实现方式二：将要计算的多项式经过通分来计算。

上面的前 n 项和，可以使用结合律：f(x) = a0 + x * (a1 + ... + x ^ (n-4)(an-4 + x * (an-3 + x * (an-2 + (an-1 * x)))))

于是把程序改写成

```
    function count(x, arr) {
        let length = arr.length;
        let result = arr[length - 1];
        
        for(let i = 1; i < length; i ++) {
            result = arr[length - (i + 1)] + result * x
        }
        return result;
    }
```

上面两段代码，看起来代码行数差不错，但是执行速度相差了一个数量级，原因在于脚本的乘法运算的速度，要比幂运算的速度快的多。把前一次的计算结果作为值传入后一次是非常明智的选择。


## 结论

上面的实验结果说明，相同的需求，与不同算法的巧妙程度有关。

想要更加巧妙的，除了要对计算机执行不同计算的执行时间有了解之外，如何组织合理的算法尤为重要。


# 总结整理

那现在，到底什么是数据结构呢，什么又是算法呢？

#### 数据结构，就是数据对象在计算机中的组织方式。

那这种组织方式，其实有两个方面的描述

- 1、一个是数据对象的逻辑结构（堆栈，队列，树，图...等等）

比如说，图书馆中的图书按照书的类别进行分类，那一个类别下面肯定有很多本书，这种类别与书一对多的关系，就叫做树的逻辑结构

又比如，在图书馆中某个类别下面有很多本书，对于某一本书，又有多少人买过，买了这本书的人又买了哪些其他的书。这种：类别 - 书 - 买书的人 - 买书的人买过的书形成的关系网，就形成了多对多的逻辑结构，这种逻辑结构叫做图。

- 2、数据对象在计算机中的物理存储结构（大致可以理解为数组和链表两种不行形式）

物理存储结构其实意思就是，数据对象在计算机中也是需要按照一定的形式进行存储，那具体是按照什么样的形式存储呢？是按照数组的方式进行顺序排列存储呢，还是按照链表的形式不规则位置存储的呢。这就是所谓的物理存储结构。

数据对象之间不是孤立的，通过加在这些数据上面的操作将数据对象联系起来，实现这些操作的过程就是算法。


### 数据结构（一种抽象的数据类型）

关键词： 数据类型、抽象

- 数据类型

    - 数据对象集

    - 数据对象相关联的操作集

- 抽象：描述数据类型的方法，不依赖于具体的实现

    - 应该与机器无关

    - 跟数据存储的物理结构无关

    - 跟实现算法的编程语言无关
    
